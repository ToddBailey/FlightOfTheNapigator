// IR Comm Bit Banging
// ------------------------------------------------
// Wed Mar 12 21:19:07 EDT 2014
// TMB

// This is adapted pretty heavily from some earlier power line communication libraries.

// Carrier is now IR rate carrier (often 38kHz)
// Bit timings should often be subject to the timings specified for a given receiver module.
// NOTE -- the below protocol allows for up to 255 bytes in a data frame.
// It is possible to allocate fewer if you aren't going to use them, but it's up to the user to make sure 
// they don't overrun any buffers.

// For Vishay TSOP383:

// Min burst:										6 cycles
// Max burst length before extended gap needed:		35 cycles
// Off time after normal burst:						10 cycles
// Off time after >35cy burst:						>6x burst length

// At 38kHz, 1 cycle:								26.3uS
// Data rate, 30cy per bit:							1267bps
// Bit time:										789uS
// Min packet time (17+24+1 bits):					~33mS

// Hardware needed:
// PWM pin to generate carrier (for Tx)												--		OC0A							
// 16-bit timer with input capture pin interrupt to time incoming bits (for Rx)		--		Timer/Counter1 and ICP1 pin
// 16-bit timer interrupt to generate bit timings on the output (for Tx)			--		Same as above, just without the pin.

//----------------------------------------------------------------------

// The PLC uses timer D0 for generating the carrier signal during
// transmit, and timer F0 for generating the bit times.
// 
// Transmissions on the PLC take place as "frames" of data.
// The PLC idles with the carrier off.
//
// Each frame begins by sending a frame header.
//
// The frame header is generated by causing the carrier to transition
// between on and off 16 times with a delay of BIT_TIME between each
// transition. After the 16 transitions, there's a 2 BIT_TIME delay
// before the first bit of data is sent. The frame header lasts exactly
// 17*BIT_TIME.
//
// The frame header allows any AGC/data slicer/capacitance in the
// receiver to reach equalibrium, and gives the receiver a unique pattern
// to hunt for which indicates the start of a frame. Typically the
// receiver only looks for 8 or more transitions of the cycling carrier
// followed by the 2*BIT_TIME delay as an indication of the start of a
// frame.
//
// Immediately following the frame header, the frame data is sent. Frame
// data is always sent in groups of 8-bits (bytes). Each bit lasts
// exactly 1 BIT_TIME. If a 0 is to be sent, the carrier is modulated on
// for 1/3 of the BIT_TIME, and off for 2/3 of the BIT_TIME. If a 1 is
// to be sent, the opposite is true (carrier on for 2/3, off for 1/3).
// Bits are sent MSb to LSb for each byte.
// The first byte following a frame header gives the frame data length
// (in bytes (0 is allowed)). Then that many frame data bytes
// are sent, and finally a checksum byte is sent. The checksum is
// calculated such that the sum of all of the frame data bytes and the
// checksum byte modulo 256 will be 0.
// After the checksum byte is sent, a single stop bit (of '0') is sent.
// This gives the receiver a transition interrupt allowing it to collect
// the last bit of the checksum, and provides the spacing between this
// frame and subsequent frames being sent on the interface. Once a
// complete frame has been sent, the next frame may be sent immediately.
// 
// In the following diagrams, the level is high when carrier is
// present, and low when it is not. NOTE: the Rx code actually does
// not care what the levels are -- it works entirely by watching
// for transitions.
//
// Frame header:
//
//  ----      ----      ----      ----      ----      ----      ----      ----
// |    |____|    |____|    |____|    |____|    |____|    |____|    |____|    |____|____|
//
// ^    ^                                                                     ^         ^
// |____|____ BIT_TIME                                         2*BIT_TIME_____|_________|
//
//
// Data byte (0xC5):
//
// |  1 |  1 |  0 |  0 |  0 |  1 |  0 |  1 |
//
//  --   --   -    -    -    --   -    --
// |  |_|  |_| |__| |__| |__|  |_| |__|  |_
//
// ^    ^
// |____|____ BIT_TIME

#include	"includes.h"

#define		CARRIER_FREQUENCY			(38000)							// frequency in Hz of the IR carrier signal
#define		CARRIER_TOGGLE_CYCLES		((F_CPU/CARRIER_FREQUENCY)/2)	// length in cpu cycles between transitions of the carrier

#define		BIT_RATE					(1267)					// tells how many bits there are per second
#define		BIT_TIME					((F_CPU)/BIT_RATE)		// length in timer cycles of each bit
#define		BIT_SLOP					(BIT_TIME/4)			// amount of slop we'll allow in the time for each received bit

#define		FRAME_HEADER_TRANSITIONS	(16)				// number of transitions of the carrier to send in a frame header


enum	// IR transmit states
{
	TRANSMIT_START,
	TRANSMIT_FRAME_HEADER_TRANSITIONS,
	TRANSMIT_FRAME_HEADER_SILENCE,
	TRANSMIT_DATA_BIT_BEGIN,
	TRANSMIT_DATA_BIT_FINISH,
	TRANSMIT_STOP_BIT_BEGIN,
	TRANSMIT_STOP_BIT_FINISH,
	TRANSMIT_WAIT_STOP_SENT,
	TRANSMIT_COMPLETE,				// when transmitter reaches this state, it has finished (and receiver has been restarted)
};

enum	// IR receive states
{
	RECEIVE_IDLE,					// receive code looking for anything
	RECEIVE_MAYBE_FRAME_HEADER,		// receive code is counting frame header cycles
	RECEIVE_IN_FRAME_HEADER,		// receive code sees enough frame header cycles
	RECEIVE_DATA_BIT_BEGIN,
	RECEIVE_DATA_BIT_FINISH,
};

static volatile unsigned char
	receiveState,					// current state of the receive state machine
	transmitState;					// current state of the transmit state machine

static unsigned int
	lastEdgeTime;					// used by receiver IRQ to keep track of the last time an interrupt arrived
static unsigned char
	irqIndex;						// generic index value used by the rx and tx state machines (counts cycles and bits)
static bool
	frameLengthDone;				// used by frame emitter and collection state machines (tells if frame length byte has been handled)
static unsigned char
	frameChecksum;					// used when calculating checksums for Tx/Rx frames

static bool
	rxDataValid;					// tells if a received frame is sitting in the frame buffer
static unsigned char
	frameLength;					// number of bytes in the IR frame buffer (used for both Tx and Rx)
static unsigned char
	frameIndex;						// used to keep track of which byte of the frame buffer is being sent/received currently
static unsigned char
	frameBuffer[32];				// buffer which holds incoming and outgoing IR frames

static void IrCarrierState(bool on)
// Turn on/off the IR carrier signal.
// NOTE: this should only be called when the hardware is
// in Tx mode (IrSetupTx has been called more recently than
// IrSetupRx).
{
	if(!on)
	{
		TCCR0A=0x00;		// Ports normal (timer doesn't control output)
		TCCR0B=0x00;		// Stop timer, no prescale.
		PORTD&=~(1<<6);		// Make sure pin is low for now.
	}
	else
	{
		TCNT0=0;			// Initialize the counter to 0.
		TIFR0=0xFF;			// Clear the interrupt flags by writing ones.		
		TCCR0A=0x42;		// Toggle on match, start setting to CTC mode
		TCCR0B=0x01;		// Start the timer in CTC mode, prescaler at 1/1
	}
}

static void StopIrTimers(void)
// Stop and reset timers 0 and 1 which are used to run the IR.
{
	unsigned char
		sreg;

	sreg=SREG;
	cli();											// pause IRQ

	// Disable the bit timer (TIMER1)
	TCCR1B=0;			// Stop the timer.
	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
	TCCR1A=0;			// Normal Ports.

	// Disable carrier PWM timer (OC0A)
	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
	TCCR0A=0x00;		// Ports normal
	TCCR0B=0x00;		// Stop timer, no prescale.
	PORTD&=~(1<<6);		// Make sure pin is low for now.

	SREG=sreg;										// restore IRQ
}

static void IrSetupRx(void)
// Place the IR hardware into Rx mode.
// In Rx mode:
// Timer1 is used in input capture mode to look
// at the time between edges of the incoming signal.
// Timer0 is shutdown (unused).
// NOTE: StopIrTimers must have been called, and the Rx state machine
// must have been configured before this is called. Once this is called,
// the Rx state machine will start receiving interrupts.
{
	// PWM timer/pin needs no changes.

	// Bit timer (TIMER1) should be set up to generate ICP events on both edges BUT the Atmegas can't do that.
	// So start on an arbitrary edge for now and deal with this in the ISR
	TCNT1=0;							// Set the counter to 0.
	TIFR1|=(1<<ICF1);					// Clear Input Capture interrupt flag.
	TCCR1B=((1<<ICES1)|(1<<CS10));		// Trigger on a rising edge (arbitrary) and start the timer
	TIMSK1|=(1<<ICIE1);					// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
}

static void IrSetupTx(void)
// Place the IR hardware into Tx mode.
// In Tx mode:
// Timer0 OC0A is used to generate the carrier.
// Timer1 is used to generate interrupts to modulate the carrier.
// NOTE: StopIrTimers must have been called, and the Tx state machine
// must have been configured before this is called. Once this is called,
// the Tx state machine will start receiving interrupts.
{
	// setup timer0 to generate the carrier, but leave it disconnected from the
	// output pin (we'll connect and disconnect it from the output to modulate
	// the carrier).
	TIMSK0=0x00;							// Disable all Timer 0 associated interrupts.
	OCR0A=CARRIER_TOGGLE_CYCLES;			// Set the compare register to toggle appropriately to generate carrier
	TCNT0=0;								// Initialize the counter to 0.
	TIFR0=0xFF;								// Clear the interrupt flags by writing ones.		
	TCCR0A=0x00;							// Ports normal
	TCCR0B=0x00;							// Stop timer, no prescale.

	DDRD|=(1<<6);		// And make carrier pin an output.
	PORTD&=~(1<<6);		// Make sure it is low for now.

	// setup timer F0 so it can be used to generate interrupts to modulate the carrier
	// This means removing the input capture and setting the timer up interrupt on compare matches

	TIMSK1=0x00;						// Disable all Timer 1 associated interrupts.
	TCNT1=0;							// Set the counter to 0.
	TIFR1|=((1<<ICF1)|(1<<OCF1A));		// Clear Input Capture interrupt flag and compare match interrupt flag
	OCR1A=10;							// make the initial compare value very small so we interrupt and start transmission as soon as the timer is started
	TIMSK1|=(1<<OCIE1A);				// Enable the compare match interrupt.
	TCCR1B=((1<<WGM12)|(1<<CS10));		// Start bit timer in CTC mode.  We will interrupt very soon.
}

static void IrStartRx(void)
// This is called to restart the IR reception state machine
// after a transmission has completed (and also the first time from
// init).
{
	StopIrTimers();						// stop timers
	lastEdgeTime=0;							// reset last edge time
	receiveState=RECEIVE_IDLE;				// point Rx state machine to the start
	transmitState=TRANSMIT_COMPLETE;		// no transmission in progress now
	IrSetupRx();							// setup hardware to interrupt on edges
}

static bool InRange(unsigned int testValue,unsigned int desiredValue,unsigned int slop)
// Return true if testValue is the same as desiredValue (with slop)
{
	return((testValue<=desiredValue+slop)&&(testValue>=desiredValue-slop));
}


/*
// Functions for debugging IR bus
static volatile bool
	newByte=false;
static volatile unsigned char
	irByte;

bool HaveNewIrByte(void)
{
	if(newByte)
	{
		return(true);
	}
	return(false);
}

unsigned char GetIrByte(void)
{
	newByte=false;
	return(irByte);
}
*/

static volatile bool
	badIrMessage=false;

bool GotIrRxError(void)
// Returns true if there was an error receiving a IR frame.
// This means a bit length was out of spec or a checksum was wrong
{
	if(badIrMessage==true)		// Return true and clear error flag
	{
		badIrMessage=false;	
		return(true);
	}
	return(false);				// No reception error currently
}

static bool FrameCollector(unsigned char byte)
// A new byte has arrived on the IR interface -- add it to the
// current frame.
// Return true when the full frame has been received (even if it is not valid).
{
	bool
		frameComplete;

//newByte=true;
//irByte=byte;

	frameComplete=false;
	if(!frameLengthDone)
	{
		frameLength=byte;			// number of bytes to collect
		frameIndex=0;				// start writing bytes here
		frameChecksum=0;			// reset checksum calculation
		frameLengthDone=true;
	}
	else if(frameIndex<frameLength)	// still room to write bytes into the frame buffer?
	{
		frameBuffer[frameIndex]=byte;
		frameChecksum+=byte;
		frameIndex++;
	}
	else	// at end of data -- get checksum and validate
	{
		frameChecksum+=byte;
		if(frameChecksum==0)		// correct checksum?
		{
			rxDataValid=true;		// remember that we've got data in the RX buffer
			badIrMessage=false;	// Nothing wrong with this message
		}
		else
		{
			badIrMessage=true;						// IR message began being received but something was wrong with it
		}
		frameComplete=true;			// tell caller that we're at the end (and we don't want any additional bytes sent to us)
	}
	return(frameComplete);
}

static void ResetFrameCollector(void)
// Reset the frame collection state machine.
{
	frameLengthDone=false;
}

ISR(TIMER1_CAPT_vect)
// IR Receiver interrupt vector -- Timer 1 input capture
// If we are here, we are looking for comparator toggles which can indicate incoming bits.  We should be triggering on both edges.
// We read in the 16 bit compare register to see how long it's been since the last toggle
{
	unsigned int
		count;
	unsigned int
		timeSinceLast;
	static unsigned char
		receivedByte;
	static unsigned int
		bitTimeA;
	unsigned int
		bitTimeB;

	count=ICR1;				// read capture register

	TCCR1B^=(1<<ICES1);		// Flip edge sensitivity
	TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
	
	timeSinceLast=count-lastEdgeTime;					// find out how much time has passed (might have wrapped, but we don't care)
	lastEdgeTime=count;									// keep for next time

	switch(receiveState)
	{
		case RECEIVE_IDLE:								// receive code looking for anything
			if(InRange(timeSinceLast,BIT_TIME,BIT_SLOP))	// does this look like a frame header transition?
			{
//newByte=true;
//irByte=0x01;
				irqIndex=0;								// count transitions here
				receiveState=RECEIVE_MAYBE_FRAME_HEADER;
			}
			break;
		case RECEIVE_MAYBE_FRAME_HEADER:
			if(InRange(timeSinceLast,BIT_TIME,BIT_SLOP))	// does this look like a frame header transition?
			{
//newByte=true;
//irByte=0x02;
				irqIndex++;
				if(irqIndex>=FRAME_HEADER_TRANSITIONS/2)	// enough transitions seen to call this a frame header?
				{
//newByte=true;
//irByte=0x03;

					receiveState=RECEIVE_IN_FRAME_HEADER;	// seeing frame header transitions
				}
			}
			else
			{
				receiveState=RECEIVE_IDLE;				// back to idle
			}
			break;
		case RECEIVE_IN_FRAME_HEADER:
			if(InRange(timeSinceLast,BIT_TIME,BIT_SLOP))	// does this look like a frame header transition?
			{
				// just stay here
			}
			else if(InRange(timeSinceLast,2*BIT_TIME,2*BIT_SLOP))	// silence before the data bits?
			{
				if(!rxDataValid)
				{
					ResetFrameCollector();					// reset frame collection state machine
					irqIndex=0;								// reset bit counter
					receiveState=RECEIVE_DATA_BIT_BEGIN;	// handle first half of bit
//newByte=true;
//irByte=0x04;
				}
				else
				{
					receiveState=RECEIVE_IDLE;			// got new frame data before old data was collected -- ignore the new data
				}
			}
			else
			{
				badIrMessage=true;						// IR message began being received but something was wrong with it
				receiveState=RECEIVE_IDLE;				// something weird seen, back to idle now
			}
			break;
		case RECEIVE_DATA_BIT_BEGIN:
			if(timeSinceLast<BIT_TIME+BIT_SLOP)			// make sure this looks feasable as a data bit
			{
				bitTimeA=timeSinceLast;
				receiveState=RECEIVE_DATA_BIT_FINISH;	// wait for last transition of the bit
//newByte=true;
//irByte=0x05;
			}
			else
			{
//newByte=true;
//irByte=0x0A;
				badIrMessage=true;						// IR message began being received but something was wrong with it
				receiveState=RECEIVE_IDLE;				// something weird seen, back to idle now
			}
			break;
		case RECEIVE_DATA_BIT_FINISH:
			bitTimeB=timeSinceLast;
			if(InRange(bitTimeA+bitTimeB,BIT_TIME,BIT_SLOP))	// does this look like a bit?
			{
//newByte=true;
//irByte=0x06;
				// add the bit to the growing byte
				receivedByte<<=1;
				if(bitTimeA>bitTimeB)					// bit is a 1
				{
					receivedByte|=1;
				}
				irqIndex++;
				if(irqIndex>=8)							// enough bits for a byte?
				{
					irqIndex=0;							// reset for next byte
					if(FrameCollector(receivedByte))	// add the byte to a frame that's being collected
					{
						receiveState=RECEIVE_IDLE;		// at end, go back to idle -- wait for next frame header
					}
				}
				receiveState=RECEIVE_DATA_BIT_BEGIN;	// go get the next bit
			}
			else
			{
				badIrMessage=true;						// IR message began being received but something was wrong with it
				receiveState=RECEIVE_IDLE;				// something weird seen, back to idle now
			}
			break;
	}
}

static bool FrameEmitter(unsigned char *byte)
// Get the next frame byte to send.
// Return true when on the last byte (checksum).
{
	bool
		frameComplete;

	frameComplete=false;
	if(!frameLengthDone)
	{
		*byte=frameLength;			// byte to emit
		frameIndex=0;				// start reading bytes here
		frameChecksum=0;			// reset checksum calculation
		frameLengthDone=true;
	}
	else if(frameIndex<frameLength)	// still bytes to read from the frame buffer?
	{
		*byte=frameBuffer[frameIndex];
		frameChecksum+=*byte;
		frameIndex++;
	}
	else	// at end of data -- send checksum
	{
		*byte=0-frameChecksum;
		frameComplete=true;			// tell caller that we're at the end (and we don't have any additional bytes to emit)
	}
	return(frameComplete);
}

static void ResetFrameEmitter(void)
// Reset the frame emitter state machine.
{
	frameLengthDone=false;
}

ISR(TIMER1_COMPA_vect)
// Transmitter interrupt vector -- timer 0 output compare
// If we're here, transmission is happening.  Getting here means the bit timer has reached the correct number of cycles, has reset, and needs to know what to do on the next match.
// In this ISR, we gate the transmission carrier on or off and also time the bits as they go out.
{
	static unsigned int
		bitOnTime;
	static unsigned char
		byteToEmit;
	static bool
		sendingLastByte;

	switch(transmitState)
	{
		case TRANSMIT_START:			// called at the first interrupt (which happens quickly once IrSetupTx has been called)
			OCR1A=BIT_TIME;				// Start preamble -- next interrupt in this many cycles (toggle at bit times to sync receiver)
			TIFR1|=(1<<OCF1A);			// clear interrupt flag (it may have triggered again on entry because the initial rate is set quite fast)
			irqIndex=1;									// count up transitions of the header (this state makes the first transition)
			IrCarrierState(true);						// turn on the carrier
			transmitState=TRANSMIT_FRAME_HEADER_TRANSITIONS;	// output header transitions
			break;
		case TRANSMIT_FRAME_HEADER_TRANSITIONS:
			OCR1A=BIT_TIME;								// next interrupt in this many cycles
			irqIndex++;									// count up transitions of the header
			IrCarrierState(irqIndex&1);				// toggle carrier output state
			if(irqIndex>=FRAME_HEADER_TRANSITIONS-1)
			{
				transmitState=TRANSMIT_FRAME_HEADER_SILENCE;	// output the silence
			}
			break;
		case TRANSMIT_FRAME_HEADER_SILENCE:
			OCR1A=2*BIT_TIME;							// interrupt once the silence is complete
			IrCarrierState(false);						// turn off the carrier
			ResetFrameEmitter();						// set up frame emitter state machine
			irqIndex=0;									// bit offset
			sendingLastByte=FrameEmitter(&byteToEmit);
			transmitState=TRANSMIT_DATA_BIT_BEGIN;		// output the first half of a data bit
			break;
		case TRANSMIT_DATA_BIT_BEGIN:					// check bit value, and begin sending
			bitOnTime=((unsigned long)BIT_TIME*33)/100;
			if(byteToEmit&0x80)							// turn xmitter on for correct time
			{
				bitOnTime=BIT_TIME-bitOnTime;
			}
			OCR1A=bitOnTime;
			IrCarrierState(true);						// turn off the carrier
			transmitState=TRANSMIT_DATA_BIT_FINISH;
			break;
		case TRANSMIT_DATA_BIT_FINISH:					// check bit value, and finish sending.  Check to see if we're done
			OCR1A=BIT_TIME-bitOnTime;				// turn off for the remainder
			IrCarrierState(false);						// turn off the carrier
			irqIndex++;
			if(irqIndex<8)
			{
				byteToEmit<<=1;
				transmitState=TRANSMIT_DATA_BIT_BEGIN;
			}
			else
			{
				if(!sendingLastByte)					// still more bytes to send in this frame?
				{
					irqIndex=0;
					sendingLastByte=FrameEmitter(&byteToEmit);
					transmitState=TRANSMIT_DATA_BIT_BEGIN;
				}
				else
				{
					transmitState=TRANSMIT_STOP_BIT_BEGIN;	// begin sending the stop bit
				}
			}
			break;
		case TRANSMIT_STOP_BIT_BEGIN:					// transmitter is on, last bit now locked into receiver
			bitOnTime=((unsigned long)BIT_TIME*33)/100;
			OCR1A=bitOnTime;
			IrCarrierState(true);						// turn off the carrier
			transmitState=TRANSMIT_STOP_BIT_FINISH;
			break;
		case TRANSMIT_STOP_BIT_FINISH:					// transmitter is off after stop bit, end transmission
			OCR1A=BIT_TIME-bitOnTime;
			IrCarrierState(false);						// turn off the carrier
			transmitState=TRANSMIT_WAIT_STOP_SENT;
			break;
		case TRANSMIT_WAIT_STOP_SENT:					// once this gets called, the complete stop bit has been sent
			IrStartRx();								// turn the receiver back on (also sets transmitState to TRANSMIT_COMPLETE)
			break;
		case TRANSMIT_COMPLETE:							// placeholder state that tells outside code that the transmit is finished
			break;
	}
}

void IrRxFrame(unsigned char length,unsigned char *frameData)
// Fill frameData with length bytes of received data.
// length should be <= to the length that was returned in a previous
// call to IrCheckRxFrame.
// NOTE: If another frame of data starts arriving before this is
// called to read the previous frame, the new data is dropped.
// NOTE: Once this is called, the receiver state machine is
// reset to collect the next frame.
{
	memcpy(frameData,frameBuffer,length);		// copy over what was last received
	rxDataValid=false;							// allow reception of more frames now
}

bool IrCheckRxFrame(unsigned char *length)
// Check to see if a frame has been collected on the IR interface.
// If one has, return true, and set *length to indicate the number
// of bytes that have been collected.
// NOTE: Once this returns true, until IrRxFrame is subsequently called,
// the receiver state machine is shut down. It is the caller's responsibility
// to collect incoming frames as fast as they can arrived.
{
	if(rxDataValid)
	{
		*length=frameLength;
		return(true);
	}
	return(false);
}

bool IrTxComplete(void)
// Return true if no frame is being transmitted (by us) currently.
{
	return(transmitState==TRANSMIT_COMPLETE);
}

void IrTxFrame(unsigned char length,const unsigned char *frameBytes)
// Transmit the frame of data given by length and frameBytes out on
// the IR. This will add the header and the checksum to the frame
// as it is transmitted.
// The frame transmission is not spectacularly fast, so this processes
// it in the background. The frame data bytes are copied before the
// function returns, so the caller does not need to guarantee they stay
// in scope after the call.
// NOTE: If this is called before a previous call finishes sending, it will
// block waiting for that call to finish before it returns.
{
	// sit and spin while any previous Tx completes
	while(!IrTxComplete())
		;

	StopIrTimers();					// shutdown Tx and Rx state machines

	rxDataValid=false;					// any frame that was collected by the Rx state machine gets killed

	// copy the incoming data so it may be freed by the caller while we send in the background
	frameLength=length;					// number of bytes in the IR frame buffer (used for both Tx and Rx)
	memcpy(frameBuffer,frameBytes,length);	// copy over the bytes

	transmitState=TRANSMIT_START;		// xmit state machine to the beginning

	IrSetupTx();						// turn on timers in Tx mode (transmission starts)
}

void UnInitIr(void)
// Turn off IR handling -- stop any timers we used.
{
	StopIrTimers();
	PRR|=(1<<PRTIM1);	// Turn the TMR1 power off.
	PRR|=(1<<PRTIM0);	// Turn the TMR0 power off.
}

void InitIr(void)
// Sets all port pins to the correct states, powers up all modules needed, and initializes variables for data transfer.
// We transmit bytes by gating a PWM pin.  We use XXX to do this.  We use a separate timer (TIMER1) to do bit timing.
// We receive bytes through an integrated IR receiver, which comes in to the TIMER1 ICP1 pin.  Set it to input compare, and interrupt on both edges.
// NOTE -- we can only do one thing at a time on this timer, which is fine since we can't transmit and receive at the same time anyway.
{
	// Init the bit timer for tx and rx (TIMER1) but don't start it going yet.
	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
	OCR1A=0;			// Set the compare register arbitrarily
	TCCR1A=0;			// Normal Ports.
	TCCR1B=0;			// Stop the timer.
	TCNT1=0;			// Initialize the counter to 0.
	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
	// Make the receive pin an input
	DDRB&=~(1<<0);
	PORTB&=~(1<<0);

	// Init the PWM out for carrier generation (OC0A)
	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
	OCR0A=CARRIER_TOGGLE_CYCLES;			// Set the compare register to toggle appropriately to generate carrier
	TCNT0=0;			// Initialize the counter to 0.
	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.		

//	TCCR0A=0x42;		// Toggle on match, start setting to CTC mode
//	TCCR0B=0x01;		// Start the timer in CTC mode, prescaler at 1/1
	TCCR0A=0x00;		// Ports normal
	TCCR0B=0x00;		// Stop timer, no prescale.

	DDRD|=(1<<6);		// And make carrier pin an output.
	PORTD&=~(1<<6);		// Make sure it is low for now.

	rxDataValid=false;		// no frame waiting to be collected
	IrStartRx();			// start up in receive mode
}
